<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZJX</title>
  
  <subtitle>Zhao Jiaxing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhaojiaxing.top/"/>
  <updated>2018-05-02T05:16:54.654Z</updated>
  <id>http://www.zhaojiaxing.top/</id>
  
  <author>
    <name>ZJX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-责任链模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/02/设计模式-责任链模式/</id>
    <published>2018-05-02T05:09:11.000Z</published>
    <updated>2018-05-02T05:16:54.654Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象处理者角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。&lt;/li&gt;
&lt;li&gt;具体处理者角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/02/设计模式-代理模式/</id>
    <published>2018-05-02T02:43:22.000Z</published>
    <updated>2018-05-02T02:52:07.903Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象角色：通过接口或抽象类声明真实角色实现的业务方法。&lt;/li&gt;
&lt;li&gt;代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;/li&gt;
&lt;li&gt;真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux-vmstat命令</title>
    <link href="http://www.zhaojiaxing.top/2018/04/27/Linux-vmstat%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.zhaojiaxing.top/2018/04/27/Linux-vmstat命令/</id>
    <published>2018-04-27T08:35:32.000Z</published>
    <updated>2018-04-27T09:30:10.084Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 命令的含义为显示虚拟内存状态（「Viryual Memor Statics」），但是它可以报告关于进程、内存、I/O等系统整体运行状态。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vmstat(选项)(参数)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.zhaojiaxing.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.zhaojiaxing.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-享元模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/27/设计模式-享元模式/</id>
    <published>2018-04-27T07:52:03.000Z</published>
    <updated>2018-04-27T08:32:23.748Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;享元模式使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象享元角色：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。&lt;/li&gt;
&lt;li&gt;具体享元角色：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。&lt;/li&gt;
&lt;li&gt;享元工厂角色：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键！&lt;/li&gt;
&lt;li&gt;客户端角色：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-try_files理解</title>
    <link href="http://www.zhaojiaxing.top/2018/04/27/Nginx-try-files%E7%90%86%E8%A7%A3/"/>
    <id>http://www.zhaojiaxing.top/2018/04/27/Nginx-try-files理解/</id>
    <published>2018-04-27T06:02:36.000Z</published>
    <updated>2018-04-27T06:09:10.943Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;以 &lt;code&gt;try_files $uri $uri/ /index.php;&lt;/code&gt; 为例&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当用户请求 &lt;code&gt;http://servers.blog.ustc.edu.cn/example&lt;/code&gt; 时，这里的 &lt;code&gt;$uri&lt;/code&gt; 就是 &lt;code&gt;/example&lt;/code&gt;。&lt;code&gt;try_files&lt;/code&gt; 会到硬盘里尝试找这个文件。如果存在名为 &lt;code&gt;/$root/example&lt;/code&gt;的文件，就直接把这个文件的内容发送给用户。&lt;/li&gt;
&lt;li&gt;如果未找到 &lt;code&gt;example&lt;/code&gt; 的文件，然后就看 &lt;code&gt;$uri/&lt;/code&gt;，增加了一个 &lt;code&gt;/&lt;/code&gt;，也就是看有没有名为 &lt;code&gt;/$root/example/&lt;/code&gt; 的目录。&lt;/li&gt;
&lt;li&gt;如果又未找到，就会 &lt;code&gt;fall back&lt;/code&gt; 到 &lt;code&gt;try_files&lt;/code&gt; 的最后一个选项 &lt;code&gt;/index.php&lt;/code&gt;，发起一个内部 「子请求」，也就是相当于 &lt;code&gt;nginx&lt;/code&gt; 发起一个 &lt;code&gt;HTTP&lt;/code&gt; 请求到 &lt;code&gt;http://servers.blog.ustc.edu.cn/index.php&lt;/code&gt;。这个请求会被 &lt;code&gt;location ~ \.php$ { ... } catch&lt;/code&gt;住，也就是进入 &lt;code&gt;FastCGI&lt;/code&gt; 的处理程序。具体的 &lt;code&gt;URI&lt;/code&gt; 及参数在 &lt;code&gt;REQUEST_URI&lt;/code&gt; 中传递给 &lt;code&gt;FastCGI&lt;/code&gt; 和 程序，因此不受 &lt;code&gt;URI&lt;/code&gt; 变化的影响。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-内置变量</title>
    <link href="http://www.zhaojiaxing.top/2018/04/26/Nginx-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/26/Nginx-内置变量/</id>
    <published>2018-04-26T00:49:49.000Z</published>
    <updated>2018-04-26T01:37:52.501Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;$arg_name&lt;/code&gt;：请求中的参数名，即「?」后面的&lt;code&gt;arg_name=arg_value&lt;/code&gt;形式的&lt;code&gt;arg_name&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$args&lt;/code&gt;：请求中的参数值，即「?」后面的&lt;code&gt;arg_name=arg_value&lt;/code&gt;形式的&lt;code&gt;arg_value&lt;/code&gt;     &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$binary_remote_addr&lt;/code&gt;：客户端地址的二进制形式，固定长度为4个字节  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$body_bytes_sent&lt;/code&gt;：传输给客户端的字节数，响应头不计算在内  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$bytes_sent&lt;/code&gt;：传输给客户端的字节数  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$connection&lt;/code&gt;：TCP连接的序列号   &lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-流接口模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%B5%81%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/24/设计模式-流接口模式/</id>
    <published>2018-04-24T06:21:46.000Z</published>
    <updated>2018-04-24T06:24:06.112Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;流接口（Fluent Interface）是指实现一种面向对象的、能提高代码可读性的 API 的方法，其目的就是可以编写具有自然语言一样可读性的代码，我们对这种代码编写方式还有一个通俗的称呼——方法链。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-门面模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/24/设计模式-门面模式/</id>
    <published>2018-04-24T06:09:17.000Z</published>
    <updated>2018-04-24T06:16:11.145Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;门面模式的最初目的并不是为了避免让你阅读复杂的 API 文档，这只是一个附带作用。其实它的本意是为了降低耦合性并且遵循 Demeter 定律。&lt;/p&gt;
&lt;p&gt;一个门面旨在通过嵌入许多（但有时只有一个）接口来分离客户端和子系统。当然，也是为了降低复杂度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;门面不会禁止你访问子系统。&lt;/li&gt;
&lt;li&gt;你可以（应该）有多个门面对应一个子系统。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-依赖注入模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/24/设计模式-依赖注入模式/</id>
    <published>2018-04-24T05:53:55.000Z</published>
    <updated>2018-04-24T06:05:34.371Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;接口注入&lt;/li&gt;
&lt;li&gt;setter方法注入&lt;/li&gt;
&lt;li&gt;构造方法注入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖注入的观念就是&lt;strong&gt;将所有东西先在“外面”准备好，然后再带入“内部”的程式&lt;/strong&gt;中，如此一来你就能够在检视程式码的时候，一目了然地知道这个程式依赖著哪些类别。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-装饰模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/23/设计模式-装饰模式/</id>
    <published>2018-04-23T05:39:18.000Z</published>
    <updated>2018-04-23T05:44:49.408Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;p&gt;增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;装饰类和被装饰类可以独立发展&lt;/li&gt;
&lt;li&gt;是继承关系的替代方案&lt;/li&gt;
&lt;li&gt;优秀的扩展性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-数据映射模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/23/设计模式-数据映射模式/</id>
    <published>2018-04-23T05:24:48.000Z</published>
    <updated>2018-04-23T05:33:31.902Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;数据映射器是一种数据访问层，它执行持久性数据存储（通常是关系数据库）和内存数据表示（域层）之间的数据双向传输。 该模式的目标是保持内存表示和持久数据存储相互独立，并保持数据映射器本身。 该层由一个或多个映射器（或数据访问对象）组成，执行数据传输。 映射器实现的范围有所不同。 通用映射器将处理许多不同的域实体类型，专用映射器将处理一个或几个。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;数据库对象关系映射器（ ORM ）&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-组合模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/20/设计模式-组合模式/</id>
    <published>2018-04-20T08:30:22.000Z</published>
    <updated>2018-04-20T08:39:24.834Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。&lt;/p&gt;
&lt;h3 id=&quot;构建方式&quot;&gt;&lt;a href=&quot;#构建方式&quot; class=&quot;headerlink&quot; title=&quot;构建方式&quot;&gt;&lt;/a&gt;构建方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象构件角色Component：它为组合中的对象声明接口，也可以为共有接口实现缺省行为。&lt;/li&gt;
&lt;li&gt;树叶构件角色Leaf：在组合中表示叶节点对象——没有子节点，实现抽象构件角色声明的接口。&lt;/li&gt;
&lt;li&gt;树枝构件角色Composite：在组合中表示分支节点对象——有子节点，实现抽象构件角色声明的接口；存储子部件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥梁模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/20/设计模式-桥梁模式/</id>
    <published>2018-04-20T05:14:11.000Z</published>
    <updated>2018-04-20T06:24:40.020Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/p&gt;
&lt;h3 id=&quot;构建方式&quot;&gt;&lt;a href=&quot;#构建方式&quot; class=&quot;headerlink&quot; title=&quot;构建方式&quot;&gt;&lt;/a&gt;构建方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象（Abstraction）角色：它定义了抽象类的接口而且维护着一个指向实现（Implementor）角色的引用。&lt;/li&gt;
&lt;li&gt;精确抽象（RefinedAbstraction）角色：实现并扩充由抽象角色定义的接口。&lt;/li&gt;
&lt;li&gt;实现（Implementor）角色：给出了实现类的接口，这里的接口与抽象角色中的接口可以不一致。&lt;/li&gt;
&lt;li&gt;具体实现（ConcreteImplementor）角色：给出了实现角色定义接口的具体实现。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/20/设计模式-适配器模式/</id>
    <published>2018-04-20T00:37:21.000Z</published>
    <updated>2018-04-20T06:25:00.633Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;
&lt;h3 id=&quot;构建方式&quot;&gt;&lt;a href=&quot;#构建方式&quot; class=&quot;headerlink&quot; title=&quot;构建方式&quot;&gt;&lt;/a&gt;构建方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类适配器模式&lt;/li&gt;
&lt;li&gt;对象适配器模式&lt;/li&gt;
&lt;li&gt;接口适配器模式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-对象池模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/19/设计模式-对象池模式/</id>
    <published>2018-04-19T09:20:07.000Z</published>
    <updated>2018-04-20T06:23:49.942Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;一个对象池包含一组已经初始化过且可以使用的对象，而可以在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非直接销毁它。这是一种特殊的工厂对象。&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;运用对象池化技术可以显著地提升性能，尤其是当对象的初始化过程代价较大或者频率较高时。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-多例模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/19/设计模式-多例模式/</id>
    <published>2018-04-19T08:55:58.000Z</published>
    <updated>2018-04-19T09:33:04.853Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;多例模式：在多例模式中，多例类可以有多个实例，而且多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;p&gt;单例模式的推广版本&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/19/设计模式-原型模式/</id>
    <published>2018-04-19T08:16:14.000Z</published>
    <updated>2018-04-20T06:23:20.870Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;相比正常创建一个对象 ( new Foo() )，首先创建一个原型，然后克隆它会更节省开销。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/19/设计模式-建造者模式/</id>
    <published>2018-04-19T07:32:31.000Z</published>
    <updated>2018-04-20T06:24:18.150Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象建造者（Builder）：为创建一个Product对象的各个部件指定抽象接口。&lt;/li&gt;
&lt;li&gt;具体建造者（ConcreteBuilder）：实现Builder的接口以构造和装配该产品的各个部件。定义并明确它所创建的表示。提供一个检索产品的接口&lt;/li&gt;
&lt;li&gt;导演角色（Director）：构造一个使用Builder接口的对象。&lt;/li&gt;
&lt;li&gt;产品角色（Product）：表示被构造的复杂对象。ConcreateBuilder创建该产品的内部表示并定义它的装配过程。包含定义组成部件的类，包括将这些部件装配成最终产品的接口。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/19/设计模式-抽象工厂模式/</id>
    <published>2018-04-19T02:58:00.000Z</published>
    <updated>2018-04-20T06:24:27.943Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;
&lt;p&gt;抽象工厂模式的实质是『提供接口，创建一系列相关或独立的对象，而不指定这些对象的具体类』。&lt;/p&gt;
&lt;h3 id=&quot;产品族&quot;&gt;&lt;a href=&quot;#产品族&quot; class=&quot;headerlink&quot; title=&quot;产品族&quot;&gt;&lt;/a&gt;产品族&lt;/h3&gt;&lt;p&gt;产品族，是指位于不同产品等级结构，功能相关联的产品组成的家族。&lt;br&gt;抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/19/设计模式-工厂方法模式/</id>
    <published>2018-04-19T02:15:58.000Z</published>
    <updated>2018-04-20T06:24:01.397Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;工厂方法模式又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
