<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZJX</title>
  
  <subtitle>Zhao Jiaxing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-19T02:33:09.054Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZJX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-工厂方法模式</title>
    <link href="http://yoursite.com/2018/04/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/04/19/设计模式-工厂方法模式/</id>
    <published>2018-04-19T02:15:58.000Z</published>
    <updated>2018-04-19T02:33:09.054Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;工厂方法模式又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。&lt;/p&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建抽象工厂类，定义具体工厂的公共接口； &lt;/li&gt;
&lt;li&gt;创建抽象产品类 ，定义具体产品的公共接口； &lt;/li&gt;
&lt;li&gt;创建具体产品类（继承抽象产品类） &amp;amp; 定义生产的具体产品； &lt;/li&gt;
&lt;li&gt;创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法； &lt;/li&gt;
&lt;li&gt;外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;更符合开-闭原则，新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可&lt;/li&gt;
&lt;li&gt;符合单一职责原则，每个具体工厂类只负责创建对应的产品 &lt;/li&gt;
&lt;li&gt;子类提供挂钩。基类为工厂方法提供缺省实现，子类可以重写新的实现，也可以继承父类的实现。– 加一层间接性，增加了灵活性&lt;/li&gt;
&lt;li&gt;屏蔽产品类。产品类的实现如何变化，调用者都不需要关心，只需关心产品的接口，只要接口保持不变，系统中的上层模块就不会发生变化。&lt;/li&gt;
&lt;li&gt;典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不需要关心，符合迪米特法则，符合依赖倒置原则，符合里氏替换原则。&lt;/li&gt;
&lt;li&gt;多态性：客户代码可以做到与特定应用无关，适用于任何实体类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销&lt;/li&gt;
&lt;li&gt;重构已经存在的类会破坏客户端代码&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-简单工厂模式</title>
    <link href="http://yoursite.com/2018/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/04/18/设计模式-简单工厂模式/</id>
    <published>2018-04-18T09:01:47.000Z</published>
    <updated>2018-04-18T09:21:41.131Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;简单工厂模式又称静态工厂方法模式，简单工厂模式的工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。&lt;br&gt;还有一种说法是认为静态工厂方法模式和简单工厂模式是两种模式，详情看&lt;a href=&quot;https://laravel-china.org/docs/php-design-patterns/2018/SimpleFactory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简单工厂模式&lt;/a&gt;和&lt;a href=&quot;https://laravel-china.org/docs/php-design-patterns/2018/StaticFactory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;静态工厂方法模式&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则&lt;/li&gt;
&lt;li&gt;不修改代码的话，是无法扩展的&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://yoursite.com/2018/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/04/18/设计模式-单例模式/</id>
    <published>2018-04-18T08:20:19.000Z</published>
    <updated>2018-04-18T09:02:22.935Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。&lt;/p&gt;
&lt;h3 id=&quot;构建方式&quot;&gt;&lt;a href=&quot;#构建方式&quot; class=&quot;headerlink&quot; title=&quot;构建方式&quot;&gt;&lt;/a&gt;构建方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;懒汉方式：指全局的单例实例在第一次被使用时构建。&lt;/li&gt;
&lt;li&gt;饿汉方式：指全局的单例实例在类装载时构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实现方式&quot;&gt;&lt;a href=&quot;#实现方式&quot; class=&quot;headerlink&quot; title=&quot;实现方式&quot;&gt;&lt;/a&gt;实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;私有化一个属性用于存放唯一的一个实例。&lt;/li&gt;
&lt;li&gt;私有化构造方法，私有化克隆方法，用来创建并只允许创建一个实例。&lt;/li&gt;
&lt;li&gt;公有化静态方法，用于向系统提供这个实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
