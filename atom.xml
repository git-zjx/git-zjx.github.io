<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZJX</title>
  
  <subtitle>Zhao Jiaxing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhaojiaxing.top/"/>
  <updated>2018-05-04T06:49:28.900Z</updated>
  <id>http://www.zhaojiaxing.top/</id>
  
  <author>
    <name>ZJX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web安全-同源策略</title>
    <link href="http://www.zhaojiaxing.top/2018/05/04/Web%E5%AE%89%E5%85%A8-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>http://www.zhaojiaxing.top/2018/05/04/Web安全-同源策略/</id>
    <published>2018-05-04T05:25:08.000Z</published>
    <updated>2018-05-04T06:49:28.900Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;同源策略（Same origin
        
      
    
    </summary>
    
      <category term="Web安全" scheme="http://www.zhaojiaxing.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web安全" scheme="http://www.zhaojiaxing.top/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux-vmstat命令</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/Linux-vmstat%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/Linux-vmstat命令/</id>
    <published>2018-05-03T02:49:40.000Z</published>
    <updated>2018-05-03T02:48:47.783Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 命令的含义为显示虚拟内存状态（「Viryual Memor Statics」），但是它可以报告关于进程、内存、I/O等系统整体运行状态。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vmstat(选项)(参数)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.zhaojiaxing.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.zhaojiaxing.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-try_files理解</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/Nginx-try-files%E7%90%86%E8%A7%A3/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/Nginx-try-files理解/</id>
    <published>2018-05-03T02:49:20.000Z</published>
    <updated>2018-05-03T02:48:42.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;以 &lt;code&gt;try_files $uri $uri/ /index.php;&lt;/code&gt; 为例&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当用户请求 &lt;code&gt;http://servers.blog.ustc.edu.cn/example&lt;/code&gt; 时，这里的 &lt;code&gt;$uri&lt;/code&gt; 就是 &lt;code&gt;/example&lt;/code&gt;。&lt;code&gt;try_files&lt;/code&gt; 会到硬盘里尝试找这个文件。如果存在名为 &lt;code&gt;/$root/example&lt;/code&gt;的文件，就直接把这个文件的内容发送给用户。&lt;/li&gt;
&lt;li&gt;如果未找到 &lt;code&gt;example&lt;/code&gt; 的文件，然后就看 &lt;code&gt;$uri/&lt;/code&gt;，增加了一个 &lt;code&gt;/&lt;/code&gt;，也就是看有没有名为 &lt;code&gt;/$root/example/&lt;/code&gt; 的目录。&lt;/li&gt;
&lt;li&gt;如果又未找到，就会 &lt;code&gt;fall back&lt;/code&gt; 到 &lt;code&gt;try_files&lt;/code&gt; 的最后一个选项 &lt;code&gt;/index.php&lt;/code&gt;，发起一个内部 「子请求」，也就是相当于 &lt;code&gt;nginx&lt;/code&gt; 发起一个 &lt;code&gt;HTTP&lt;/code&gt; 请求到 &lt;code&gt;http://servers.blog.ustc.edu.cn/index.php&lt;/code&gt;。这个请求会被 &lt;code&gt;location ~ \.php$ { ... } catch&lt;/code&gt;住，也就是进入 &lt;code&gt;FastCGI&lt;/code&gt; 的处理程序。具体的 &lt;code&gt;URI&lt;/code&gt; 及参数在 &lt;code&gt;REQUEST_URI&lt;/code&gt; 中传递给 &lt;code&gt;FastCGI&lt;/code&gt; 和 程序，因此不受 &lt;code&gt;URI&lt;/code&gt; 变化的影响。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-内置变量</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/Nginx-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/Nginx-内置变量/</id>
    <published>2018-05-03T02:49:00.000Z</published>
    <updated>2018-05-03T02:48:35.854Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;$arg_name&lt;/code&gt;：请求中的参数名，即「?」后面的&lt;code&gt;arg_name=arg_value&lt;/code&gt;形式的&lt;code&gt;arg_name&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$args&lt;/code&gt;：请求中的参数值，即「?」后面的&lt;code&gt;arg_name=arg_value&lt;/code&gt;形式的&lt;code&gt;arg_value&lt;/code&gt;     &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$binary_remote_addr&lt;/code&gt;：客户端地址的二进制形式，固定长度为4个字节  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$body_bytes_sent&lt;/code&gt;：传输给客户端的字节数，响应头不计算在内  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$bytes_sent&lt;/code&gt;：传输给客户端的字节数  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$connection&lt;/code&gt;：TCP连接的序列号   &lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://www.zhaojiaxing.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-访问者模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-访问者模式/</id>
    <published>2018-05-03T02:19:35.000Z</published>
    <updated>2018-05-03T02:43:08.255Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象访问者(Visitor)：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变（不能改变的意思是说，如果元素类的个数经常改变，则说明不适合使用访问者模式）。&lt;/li&gt;
&lt;li&gt;具体访问者(ConcreteVisitor)： 给出对每一个元素类访问时所产生的具体行为。&lt;/li&gt;
&lt;li&gt;抽象节点(Element)：定义了一个接受访问者（accept）的方法，其意义是指，每一个元素都要可以被访问者访问。&lt;/li&gt;
&lt;li&gt;具体节点(ConcreteElement)：提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。&lt;/li&gt;
&lt;li&gt;结构对象角色(ObjectStructure)：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模版模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-模版模式/</id>
    <published>2018-05-03T02:07:49.000Z</published>
    <updated>2018-05-03T02:14:55.697Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;封装不变的部分，扩展可变的部分&lt;/li&gt;
&lt;li&gt;提取公共部分代码，便于维护&lt;/li&gt;
&lt;li&gt;行为由父类控制，子类实现&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-策略模式/</id>
    <published>2018-05-03T01:46:11.000Z</published>
    <updated>2018-05-03T01:51:24.870Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象策略角色：策略类，通常由一个接口或者抽象类实现。&lt;/li&gt;
&lt;li&gt;具体策略角色：包装了相关的算法和行为。&lt;/li&gt;
&lt;li&gt;环境角色：持有一个策略类的引用，最终给客户端调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-状态模式/</id>
    <published>2018-05-03T01:29:27.000Z</published>
    <updated>2018-05-03T01:51:24.730Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;环境类（Context）: 定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。&lt;/li&gt;
&lt;li&gt;抽象状态类（State）: 定义一个接口以封装与Context的一个特定状态相关的行为。&lt;/li&gt;
&lt;li&gt;具体状态类（ConcreteState）: 每一子类实现一个与Context的一个状态相关的行为。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-观察者模式/</id>
    <published>2018-05-03T01:11:02.000Z</published>
    <updated>2018-05-03T01:51:24.842Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也叫发布-订阅模式&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象目标角色（Subject）：目标角色知道它的观察者，可以有任意多个观察者观察同一个目标。并且提供注册和删除观察者对象的接口。目标角色往往由抽象类或者接口来实现。&lt;/li&gt;
&lt;li&gt;抽象观察者角色（Observer）：为那些在目标发生改变时需要获得通知的对象定义一个更新接口。抽象观察者角色主要由抽象类或者接口来实现。&lt;/li&gt;
&lt;li&gt;具体目标角色（Concrete Subject）：将有关状态存入各个Concrete Observer对象。当它的状态发生改变时, 向它的各个观察者发出通知。&lt;/li&gt;
&lt;li&gt;具体观察者角色（Concrete Observer）：存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口以使自身状态与目标的状态保持一致。在本角色内也可以维护一个指向Concrete Subject对象的引用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-空对象模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-空对象模式/</id>
    <published>2018-05-03T00:56:47.000Z</published>
    <updated>2018-05-03T01:51:24.811Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;通过对缺失对象的封装，以提供默认无任何行为的对象替代品&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象协作对象&lt;/li&gt;
&lt;li&gt;具体协作对象&lt;/li&gt;
&lt;li&gt;空对象&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-备忘录模式/</id>
    <published>2018-05-03T00:36:14.000Z</published>
    <updated>2018-05-03T01:51:24.699Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。又叫做快照模式或Token模式&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。&lt;/li&gt;
&lt;li&gt;Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。&lt;/li&gt;
&lt;li&gt;Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-中介者模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/03/设计模式-中介者模式/</id>
    <published>2018-05-03T00:22:56.000Z</published>
    <updated>2018-05-03T01:51:24.403Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Mediator–抽象中介者角色：抽象中介者角色定义统一的接口，用于各同事角色之间的通信。&lt;/li&gt;
&lt;li&gt;Concrete Mediator–具体中介者角色：具体中介者角色，通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。&lt;/li&gt;
&lt;li&gt;Colleague–同事角色：每一个同事角色都知道中介者角色，而且与其它的同事角色通信的时候，一定要通过中介者角色来协作。 每个同事类的行为分为二种：一种是同事本身的行为，这种行为叫做自发行为(Self-Method);第二种是必须依赖中介者才能完成的行为，叫做依赖行为(Dep-Method)。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-迭代器模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/02/设计模式-迭代器模式/</id>
    <published>2018-05-02T06:19:57.000Z</published>
    <updated>2018-05-02T06:31:51.421Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;它提供一种方法访问一个容器对象中各个元素， 而又不需暴露该 对象的内部细节。在PHP中我们对迭代模式的使用，通常只需实现Iterator接口即可&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;它支持以不同的方式遍历一个聚合对象。 &lt;/li&gt;
&lt;li&gt;迭代器简化了聚合类。 &lt;/li&gt;
&lt;li&gt;在同一个聚合上可以有多个遍历。 &lt;/li&gt;
&lt;li&gt;在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-命令模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/02/设计模式-命令模式/</id>
    <published>2018-05-02T05:19:59.000Z</published>
    <updated>2018-05-03T01:51:24.372Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;p&gt;Client（客户）：负责创建一个具体的命令（Concrete Command）&lt;br&gt;Invoker（调用者）：调用者持有一个命令对象，并在某个时刻调用命令对象的 execute() 方法。&lt;br&gt;Command（命令接口）：包含命令对象的 execute() 方法和 undo() 方法。&lt;br&gt;ConcreteCommand（具体命令）：实现命令接口。包括两个操作，执行命令和撤销命令。&lt;br&gt;Receiver（接收者）：接受命令并执行。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-责任链模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/02/设计模式-责任链模式/</id>
    <published>2018-05-02T05:09:11.000Z</published>
    <updated>2018-05-03T01:51:24.759Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象处理者角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。&lt;/li&gt;
&lt;li&gt;具体处理者角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://www.zhaojiaxing.top/2018/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/05/02/设计模式-代理模式/</id>
    <published>2018-05-02T02:43:22.000Z</published>
    <updated>2018-05-03T01:51:24.671Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象角色：通过接口或抽象类声明真实角色实现的业务方法。&lt;/li&gt;
&lt;li&gt;代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;/li&gt;
&lt;li&gt;真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-享元模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/27/设计模式-享元模式/</id>
    <published>2018-04-27T07:52:03.000Z</published>
    <updated>2018-05-03T01:51:24.785Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;享元模式使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象享元角色：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。&lt;/li&gt;
&lt;li&gt;具体享元角色：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。&lt;/li&gt;
&lt;li&gt;享元工厂角色：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键！&lt;/li&gt;
&lt;li&gt;客户端角色：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-流接口模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%B5%81%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/24/设计模式-流接口模式/</id>
    <published>2018-04-24T06:21:46.000Z</published>
    <updated>2018-04-24T06:24:06.112Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;流接口（Fluent Interface）是指实现一种面向对象的、能提高代码可读性的 API 的方法，其目的就是可以编写具有自然语言一样可读性的代码，我们对这种代码编写方式还有一个通俗的称呼——方法链。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-门面模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/24/设计模式-门面模式/</id>
    <published>2018-04-24T06:09:17.000Z</published>
    <updated>2018-04-24T06:16:11.145Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;门面模式的最初目的并不是为了避免让你阅读复杂的 API 文档，这只是一个附带作用。其实它的本意是为了降低耦合性并且遵循 Demeter 定律。&lt;/p&gt;
&lt;p&gt;一个门面旨在通过嵌入许多（但有时只有一个）接口来分离客户端和子系统。当然，也是为了降低复杂度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;门面不会禁止你访问子系统。&lt;/li&gt;
&lt;li&gt;你可以（应该）有多个门面对应一个子系统。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-依赖注入模式</title>
    <link href="http://www.zhaojiaxing.top/2018/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhaojiaxing.top/2018/04/24/设计模式-依赖注入模式/</id>
    <published>2018-04-24T05:53:55.000Z</published>
    <updated>2018-05-03T01:51:24.281Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。&lt;/p&gt;
&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;接口注入&lt;/li&gt;
&lt;li&gt;setter方法注入&lt;/li&gt;
&lt;li&gt;构造方法注入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖注入的观念就是&lt;strong&gt;将所有东西先在“外面”准备好，然后再带入“内部”的程式&lt;/strong&gt;中，如此一来你就能够在检视程式码的时候，一目了然地知道这个程式依赖著哪些类别。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构型" scheme="http://www.zhaojiaxing.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
    
      <category term="PHP" scheme="http://www.zhaojiaxing.top/tags/PHP/"/>
    
      <category term="设计模式" scheme="http://www.zhaojiaxing.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
